# format string 0 #
 
## Overview ##

Category: [Binary Exploitation](../../)

Topics: Format string, Binary Exploitation, picoCTF-2024

## Description ##

Can you use your knowledge of format strings to make the customers happy?

## Approach ##

I am provided a c file, `format-string-0.c`, and a binary file, `format-string-0`. Inspecting the c file, I can see that the `on_menu` function checks if the "burger" exist in the "menu". Going into the main function, the content of the flag.txt is stored in a `flag` array and calls `serve_patrick` function.

    FILE *f = fopen("flag.txt", "r");
    if (f == NULL) {
        printf("%s %s", "Please create 'flag.txt' in this directory with your",
                        "own debugging flag.\n");
        exit(0);
    }

    fgets(flag, FLAGSIZE, f);
    signal(SIGSEGV, sigsegv_handler);

    gid_t gid = getegid();
    setresgid(gid, gid, gid);

    serve_patrick();

In the `serve_patrick` function, the `scanf("%s", choice1)` reads user input and stores it in `choice1`. It then checks if the user input is in `menu1` (In this case, "Breakf@st_Burger", "Gr%114d_Cheese", or "Bac0n_D3luxe"). After that, count is assigned the return value of `printf(choice1)` and then checks if count is greater than 2*BUFSIZE (64). If count is greater than 64, then it calls `serve_bob`. Since `printf` just prints the buffer controlled by the user and one of the menu option has a format specifier, I typed in "Gr%114d_Cheese". This works because `printf` interprets `%114d` as "print an integer using at least 114 characters." This causes `printf` to keep printing until it reaches at least 114 characters, thus causing count to be at least greater than 64. 

    Welcome to our newly-opened burger place Pico 'n Patty! Can you help the picky customers find their favorite burger?
    Here comes the first customer Patrick who wants a giant bite.
    Please choose from the following burgers: Breakf@st_Burger, Gr%114d_Cheese, Bac0n_D3luxe
    Enter your recommendation: Gr%114d_Cheese
    Gr                                                                                                           4202954_Cheese
    Good job! Patrick is happy! Now can you serve the second customer?
    Sponge Bob wants something outrageous that would break the shop (better be served quick before the shop owner kicks you out!)
    Please choose from the following burgers: Pe%to_Portobello, $outhwest_Burger, Cla%sic_Che%s%steak
    Enter your recommendation:

In the `serve_bob` function, it gives us a new menu option ("Pe%to_Portobello, $outhwest_Burger, or Cla%sic_Che%s%steak"). The `scanf` once again reads the user input and stores it in `choice2`. Then it checks if the user input is in `menu2`, if it is then it will print the option I choose. The correct choice is `Cla%sic_Che%s%steak` because it contains multiple `%s` format specifiers. Since no arguments are supplied to `printf`, each `%s` causes printf to interpret arbitrary stack values as char * pointers and print memory from those addresses. 

    Please choose from the following burgers: Pe%to_Portobello, $outhwest_Burger, Cla%sic_Che%s%steak
    Enter your recommendation: Cla%sic_Che%s%steak
    ClaCla%sic_Che%s%steakic_Che(null)
    picoCTF{7h3_cu570m3r_15_n3v3r_SEGFAULT_a1d85b3e}

Flag: picoCTF{7h3_cu570m3r_15_n3v3r_SEGFAULT_a1d85b3e} 

## Reflection ## 
This challenge is a straightforward introduction to format string vulnerabilities. It hows how using printf with user-controlled input can cause the function to misinterpret format specifiers and lead to unintended behavior.