# Buffer Overflow 0 #
 
## Overview ##

Category: [Binary Exploitation](../../)

Topics: Binary Exploitation, picoCTF-2022, Buffer Overflow 

## Description ##
Let's start off simple, can you overflow the correct buffer? 

## Approach ##
I am given a binary file called vuln and a C file called vuln.c. Inspecting the C file, `sigsegv_handler` prints the flag when the signal `SIGSEGV` is received and the `main` function reads user input (via `gets`) and stores it in the buffer `buf1`. `main` will then call `vuln` with the argument `buf1` where `vuln` will copy the contents of `buf1` into a smaller buffer `buf2`:

    void sigsegv_handler(int sig) {
      printf("%s\n", flag);
      fflush(stdout);
      exit(1);
    }
  
    void vuln(char *input){
      char buf2[16];
      strcpy(buf2, input);
    }
 
    int main(int argc, char **argv){
    
    FILE *f = fopen("flag.txt","r");
    if (f == NULL) {
      printf("%s %s", "Please create 'flag.txt' in this directory with your",
                      "own debugging flag.\n");
      exit(0);
    }
    
    fgets(flag,FLAGSIZE_MAX,f);
    signal(SIGSEGV, sigsegv_handler); // Set up signal handler
    
    gid_t gid = getegid();
    setresgid(gid, gid, gid);


    printf("Input: ");
    fflush(stdout);
    char buf1[100];
    gets(buf1); 
    vuln(buf1);
    printf("The program will exit now\n");
    return 0;
    }

I noticed that `gets` and `strcpy` does not check for bounds. Although both `buf1` and `buf2` are unsafe, overflowing `buf2` is sufficient to trigger a segmentation fault inside `vuln` as overflowing `buf2` causes a segmentation fault, which raises `SIGSEGV`. The registered signal handler prints the flag before exiting.

    Input: aaaaaaaaaaaaaaaaaaaaaaaaa
    picoCTF{ov3rfl0ws_ar3nt_that_bad_ef01832d}

Flag: picoCTF{ov3rfl0ws_ar3nt_that_bad_ef01832d}

## Reflection ## 
This challenge is a simple buffer overflow challenge and it goes to show that `gets` and `strcpy` does not check for bounds which can result in user input overwriting other memory locations.



