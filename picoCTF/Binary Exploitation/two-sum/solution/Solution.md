# two-sum #
 
## Overview ##

Category: [Binary Exploitation](../../)

Topics: Binary Exploitation, picoCTF-2023, Integer Overflow

## Description ##
Can you solve this?

## Approach ##
I am provided with a C file called `flag.c`. Inspecting it shows a `addIntOvf` function that checks if adding two positive numbers (`a` and `b`) will cause result to be a negative number or adding two negative numbers(`a` and `b`) will result in a positive number, if it does, return -1. Otherwise, it will return 0:

    result = a + b;
    if(a > 0 && b > 0 && result < 0)
        return -1;
    if(a < 0 && b < 0 && result > 0)
        return -1;
    return 0;

In the `main` function, I see that it requests two integers as input and passes them to the `addIntOvf` function. If the function outputs 0, then it prints "No overflow" and exit the program. Else, if it output -1, then it prints "You have an integer overflow". Then it checks if either the user input values are greater than 0 before printing the flag. 

Noticing that one of the print statements says "You have an integer overflow" indicates that I must input two integers that would result in an integer overflow. In most modern systems, an int is 32 bits with a range of -2,147,483,648 to 2,147,483,647. Thus the two integers I should input are 2147483647 and 1. This will cause an integer overflow, so putting these integers into the program results in:

    n1 > n1 + n2 OR n2 > n1 + n2
    What two positive numbers can make this possible:
    2147483647
    1
    You entered 2147483647 and 1
    You have an integer overflow
    YOUR FLAG IS: picoCTF{Tw0_Sum_Integer_Bu773R_0v3rfl0w_f6ed8057}

Flag: picoCTF{Tw0_Sum_Integer_Bu773R_0v3rfl0w_f6ed8057}

## Reflection ## 
This small challenge demonstrated how signed integer overflow can occur in C due to the fixed size of the `int` type. It helped me understand how integer limits can affect program logic. To prevent this type of vulnerability, a programmer would need to implement proper bounds checks or use safer arithmetic functions that detect overflow.



