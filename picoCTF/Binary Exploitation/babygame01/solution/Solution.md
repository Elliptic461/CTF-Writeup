# babygame01 #
 
## Overview ##

Category: [Binary Exploitation](../../)

Topics: Binary Exploitation, picoCTF-2023, Reverse Engineering, Out-of-Bounds Writes

## Description ##
Get the flag and reach the exit.

## Approach ##
I am provided with a binary file called `game`. I started with ghidra to analyze the binary file while also having gdb open up the binary file for dynamic analysis. Looking at the decompiled code, I can see that there is a function called `init_player`, which seems to represent the player position.

Here is what happen when you run it in gdb (Shorten the board cause it was too long):

    Player position: 4 4
    End tile position: 29 89
    Player has flag: 0
    ..................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................@...............................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................X 

Also checked the binary security and found that it is a 32-bit system:

    Arch:     i386 <--- 32-bit architecture
    RELRO:      Partial RELRO
    Stack:      Canary found
    NX:         NX enabled
    PIE:        No PIE (0x8048000)
    Stripped:   No

From what I gathered from gdb, we start at position 4,4. The player must reach 29, 89 to win. I also realize that the player has flag is set to 0 by `init_player`.  

Moving on from `init_player`, `init_map`, and `print_map` does what I expected it to do (Didn't find anything interesting). After that, I moved to the `move_player` function which seems to control the player movement depending on the user input:

    if (param_2 == 'l') {
        iVar1 = getchar();
        player_tile = (undefined1)iVar1;
    }
    if (param_2 == 'p') {
        solve_round(param_3,param_1);
    }
    *(undefined1 *)(*param_1 * 0x5a + param_3 + param_1[1]) = 0x2e;
    if (param_2 == 'w') {
        *param_1 = *param_1 + -1;
    }
    else if (param_2 == 's') {
        *param_1 = *param_1 + 1;
    }
    else if (param_2 == 'a') {
        param_1[1] = param_1[1] + -1;
    }
    else if (param_2 == 'd') {
        param_1[1] = param_1[1] + 1;
    }
    *(undefined1 *)(*param_1 * 0x5a + param_3 + param_1[1]) = player_tile;

These cases is essentially broken down to:

    'w' - Move up
    'a' - Move left
    's' - Move down
    'd' - Move right
    'p' - call solve_round, move the player to the end tile
    `l` - read the next character the user types and store it as player_tile

As for `*(undefined1 *)(*param_1 * 0x5a + param_3 + param_1[1]) = player_tile;`, since `init_player` define `*param_1` as y position and `param_1[1]` as x position, this line of code is basically `map_buffer[y * 0x5a + x] = player_tile;`. Going back to main, I see the following code:

    puts("You win!");
    if (local_aa4 != '\0') {
    puts("flage");
    win();
    fflush(stdout);
    }

I noticed that there is a condition that checks if `local_aa4` does not equal to a zero value. If it does, then it calls the `win` function which prints the flag. Seeing how local_aa4 is set to 0 by `init_player`, I need to find a way to modified local_aa4 to a non zero value. Reading the decompiled code again, I noticed that there is no bound checks for `move_player` function, which means I can go out of bounds. Looking at the stack layout:

    --------------- (Higher address) 
    ...
    int local_aac <--- y position
    int local_aa8 <--- x position
    int local_aa4 <--- Flag status (Must change to non zero value)
    undefined1 local_aa0 [2700] <-- Map buffer
    ...
    --------------- (Lower address)

Since this is an i386 (32-bit x86) binary, the compiler aligns stack variables to 4-byte boundaries, placing `local_aa4` in a 4-byte slot immediately above `local_aa0` (map buffer). Thus writing to `map_buf[-4]` overwrites the least significant byte of `local_aa4`. Since I know `map_buffer[y * 0x5a + x] = player_title;`, starting from (4,4), I press `w` 4 times to reach y = 0, then press `a` 8 times to reach x = -4, which causes the write to land at `map_buf[-4]`. Doing this got me the flag:

    You win!
    flage
    picoCTF{gamer_m0d3_enabled_f3416ca2}

Flag: picoCTF{gamer_m0d3_enabled_f3416ca2}

## Reflection ## 
This is one of the first times I encountered a challenge that did not provide source code and instead only provided a compiled binary. Because of this, I had to rely on tools like Ghidra for static analysis and GDB for dynamic analysis to understand the program's behavior. Initially, it took some time since I was not used to reading decompiled code, but as I became more comfortable with it, I was able to understand how the program worked. This ultimately led me to discover that the player movement logic did not perform any bounds checking, allowing me to write out of bounds and overwrite other stack variables.

It is also important to note why I needed to write to `map_buf[-4]` instead of `map_buf[-1]`. Since this is an i386 (32-bit) system, stack variables are typically aligned to 4-byte boundaries. Even though the flag variable was declared as a char, the compiler placed it in a 4-byte aligned stack slot. As a result, writing to `map_buf[-1]` would only overwrite padding bytes, while writing to `map_buf[-4]` allowed me to overwrite the least significant byte of the flag variable and satisfy the win condition.

